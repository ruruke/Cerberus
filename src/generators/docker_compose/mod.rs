//! # Docker Compose generator
//!
//! Generates docker-compose.yaml files from Cerberus configuration.

use crate::{
    CerberusError, Result,
    config::{Config, ProxyConfig, ProxyType},
};
use std::fmt::Write;
use std::process::Command;

/// Generator for Docker Compose configurations
pub struct DockerComposeGenerator<'a> {
    config: &'a Config,
}

impl<'a> DockerComposeGenerator<'a> {
    /// Create a new Docker Compose generator
    pub fn new(config: &'a Config) -> Self {
        Self { config }
    }

    /// Generate Docker Compose YAML content
    pub fn generate(&self) -> Result<String> {
        let mut output = String::new();

        // Add header
        writeln!(output).unwrap();
        writeln!(output, "# Generated by Cerberus").unwrap();
        writeln!(output, "# Project: {}", self.config.project.name).unwrap();
        writeln!(output, "# Configuration: config.toml").unwrap();
        writeln!(output).unwrap();

        // Generate services section
        writeln!(output, "services:").unwrap();

        // Generate proxy services
        for (index, proxy) in self.config.proxies.iter().enumerate() {
            self.generate_proxy_service(&mut output, proxy, index)?;

            // Generate scaled instances if needed
            if self.config.project.scaling && proxy.instances > 1 {
                for instance in 2..=proxy.instances {
                    self.generate_scaled_proxy_instance(&mut output, proxy, index, instance)?;
                }
            }
        }

        // Generate Anubis service if enabled
        if self.config.anubis.enabled {
            self.generate_anubis_service(&mut output)?;
        }

        // Generate backend services
        for service in &self.config.services {
            // Only generate container if upstream is not an external IP
            if !self.is_external_upstream(&service.upstream) {
                self.generate_backend_service(&mut output, service)?;
            }
        }

        // Generate networks section
        self.generate_networks(&mut output)?;

        // Generate volumes section
        self.generate_volumes(&mut output)?;

        Ok(output)
    }

    /// Generate a proxy service definition
    fn generate_proxy_service(
        &self,
        output: &mut String,
        proxy: &ProxyConfig,
        index: usize,
    ) -> Result<()> {
        writeln!(output).unwrap();
        writeln!(
            output,
            "  # Proxy Layer: {} ({})",
            proxy.name,
            proxy.proxy_type.to_string()
        )
        .unwrap();
        writeln!(output, "  {}:", proxy.name).unwrap();
        writeln!(
            output,
            "    image: {}",
            self.get_proxy_image(&proxy.proxy_type)
        )
        .unwrap();
        writeln!(output, "    container_name: {}", proxy.name).unwrap();
        writeln!(output, "    restart: unless-stopped").unwrap();
        
        // ポート設定（external_portがある場合のみ）
        if let Some(external_port) = proxy.external_port {
            writeln!(output, "    ports:").unwrap();
            // ポート重複を避けるために、インデックスベースで自動調整
            let adjusted_port = if index == 0 {
                external_port
            } else {
                external_port + index as u16 * 10
            };
            writeln!(
                output,
                "      - \"{}:{}\"",
                adjusted_port, proxy.internal_port
            )
            .unwrap();
        }
        writeln!(output, "    volumes:").unwrap();
        writeln!(
            output,
            "      - ./proxy-configs/{}:{}:ro",
            proxy.name,
            self.get_proxy_config_dir(&proxy.proxy_type)
        )
        .unwrap();
        writeln!(output, "      - ./built/logs:/var/log/nginx:rw").unwrap();
        writeln!(output, "    networks:").unwrap();
        // Add networks dynamically
        for network_name in &proxy.networks {
            writeln!(output, "      - {}", network_name).unwrap();
        }
        // Fallback to default networks if none specified
        if proxy.networks.is_empty() {
            writeln!(output, "      - front-net").unwrap();
            writeln!(output, "      - back-net").unwrap();
        }

        // Add dependencies if needed
        self.generate_proxy_dependencies(output, proxy, index)?;

        // Add environment variables
        writeln!(output, "    environment:").unwrap();
        writeln!(output, "      - PROXY_LAYER={}", proxy.layer.unwrap_or(0)).unwrap();
        writeln!(
            output,
            "      - UPSTREAM={}",
            proxy.default_upstream.as_deref().unwrap_or("")
        )
        .unwrap();
        writeln!(
            output,
            "      - MAX_CONNECTIONS={}",
            proxy.max_connections.unwrap_or(1024)
        )
        .unwrap();

        // Add labels
        writeln!(output, "    labels:").unwrap();
        writeln!(output, "      - \"cerberus.service=proxy\"").unwrap();
        writeln!(
            output,
            "      - \"cerberus.layer={}\"",
            proxy.layer.unwrap_or(0)
        )
        .unwrap();
        writeln!(
            output,
            "      - \"cerberus.type={}\"",
            proxy.proxy_type.to_string()
        )
        .unwrap();

        // Add healthcheck
        writeln!(output, "    healthcheck:").unwrap();
        writeln!(
            output,
            "      test: [\"CMD\", \"{}\"]",
            self.get_proxy_healthcheck_cmd(&proxy.proxy_type)
        )
        .unwrap();
        writeln!(output, "      interval: 30s").unwrap();
        writeln!(output, "      timeout: 10s").unwrap();
        writeln!(output, "      retries: 3").unwrap();
        writeln!(output, "      start_period: 40s").unwrap();

        Ok(())
    }

    /// Generate scaled proxy instance
    fn generate_scaled_proxy_instance(
        &self,
        output: &mut String,
        proxy: &ProxyConfig,
        _index: usize,
        instance: u8,
    ) -> Result<()> {
        writeln!(output).unwrap();
        writeln!(output, "  # Scaled instance {} of {}", instance, proxy.name).unwrap();
        writeln!(output, "  {}-{}:", proxy.name, instance).unwrap();
        writeln!(
            output,
            "    image: {}",
            self.get_proxy_image(&proxy.proxy_type)
        )
        .unwrap();
        writeln!(output, "    container_name: {}-{}", proxy.name, instance).unwrap();
        writeln!(output, "    restart: unless-stopped").unwrap();
        
        // ポート設定（external_portがある場合のみ）
        if let Some(external_port) = proxy.external_port {
            writeln!(output, "    ports:").unwrap();
            writeln!(
                output,
                "      - \"{}:{}\"",
                external_port + instance as u16 - 1,
                proxy.internal_port
            )
            .unwrap();
        }
        writeln!(output, "    volumes:").unwrap();
        writeln!(
            output,
            "      - ./proxy-configs/{}:{}:ro",
            proxy.name,
            self.get_proxy_config_dir(&proxy.proxy_type)
        )
        .unwrap();
        writeln!(output, "      - ./built/logs:/var/log/nginx:rw").unwrap();
        writeln!(output, "    networks:").unwrap();
        // Add networks dynamically
        for network_name in &proxy.networks {
            writeln!(output, "      - {}", network_name).unwrap();
        }
        // Fallback to default networks if none specified
        if proxy.networks.is_empty() {
            writeln!(output, "      - front-net").unwrap();
            writeln!(output, "      - back-net").unwrap();
        }
        writeln!(output, "    environment:").unwrap();
        writeln!(output, "      - PROXY_LAYER={}", proxy.layer.unwrap_or(0)).unwrap();
        writeln!(output, "      - INSTANCE_ID={instance}").unwrap();
        writeln!(
            output,
            "      - MAX_CONNECTIONS={}",
            proxy.max_connections.unwrap_or(1024)
        )
        .unwrap();
        writeln!(output, "    labels:").unwrap();
        writeln!(output, "      - \"cerberus.service=proxy\"").unwrap();
        writeln!(
            output,
            "      - \"cerberus.layer={}\"",
            proxy.layer.unwrap_or(0)
        )
        .unwrap();
        writeln!(
            output,
            "      - \"cerberus.type={}\"",
            proxy.proxy_type.to_string()
        )
        .unwrap();
        writeln!(output, "      - \"cerberus.instance={instance}\"").unwrap();

        Ok(())
    }

    /// Generate proxy dependencies section
    fn generate_proxy_dependencies(
        &self,
        output: &mut String,
        proxy: &ProxyConfig,
        index: usize,
    ) -> Result<()> {
        let mut dependencies = Vec::new();

        // First proxy depends on Anubis if enabled
        if index == 0 && self.config.anubis.enabled {
            if let Some(upstream) = &proxy.default_upstream {
                if upstream.contains("anubis") {
                    dependencies.push("anubis");
                }
            }
        }

        // Generate depends_on section only if there are dependencies
        if !dependencies.is_empty() {
            writeln!(output, "    depends_on:").unwrap();
            for dep in dependencies {
                writeln!(output, "      - {dep}").unwrap();
            }
        }

        Ok(())
    }

    /// Generate Anubis DDoS protection service
    fn generate_anubis_service(&self, output: &mut String) -> Result<()> {
        writeln!(output).unwrap();
        writeln!(output, "  # DDoS Protection Layer").unwrap();
        writeln!(output, "  anubis:").unwrap();
        writeln!(output, "    image: {}", self.config.anubis.image).unwrap();
        writeln!(output, "    container_name: anubis").unwrap();
        writeln!(output, "    restart: unless-stopped").unwrap();
        // Anubis ports - only expose if configured
        if let Some(external_ports) = &self.config.anubis.external_ports {
            writeln!(output, "    ports:").unwrap();
            for port_mapping in external_ports {
                writeln!(output, "      - \"{}\"", port_mapping).unwrap();
            }
        }
        writeln!(output, "    volumes:").unwrap();
        writeln!(
            output,
            "      - ./anubis/botPolicy.json:/app/botPolicy.json:ro"
        )
        .unwrap();
        writeln!(output, "      - ./built/logs:/var/log/anubis:rw").unwrap();
        writeln!(output, "    networks:").unwrap();
        // Add Anubis networks dynamically
        for network_name in &self.config.anubis.networks {
            writeln!(output, "      - {}", network_name).unwrap();
        }
        // Fallback to default networks if none specified
        if self.config.anubis.networks.is_empty() {
            writeln!(output, "      - front-net").unwrap();
            writeln!(output, "      - back-net").unwrap();
        }
        writeln!(output, "    environment:").unwrap();
        writeln!(output, "      - BIND={}", self.config.anubis.bind).unwrap();
        writeln!(
            output,
            "      - DIFFICULTY={}",
            self.config.anubis.difficulty
        )
        .unwrap();
        writeln!(output, "      - TARGET={}", self.config.anubis.target).unwrap();
        writeln!(
            output,
            "      - METRICS_BIND={}",
            self.config.anubis.metrics_bind
        )
        .unwrap();
        writeln!(output, "      - SERVE_ROBOTS_TXT=\"true\"").unwrap();
        writeln!(output, "    labels:").unwrap();
        writeln!(output, "      - \"cerberus.service=ddos-protection\"").unwrap();
        writeln!(output, "      - \"cerberus.layer=anubis\"").unwrap();
        writeln!(output, "    healthcheck:").unwrap();
        writeln!(
            output,
            "      test: [\"CMD\", \"curl\", \"-f\", \"http://localhost{}/metrics\"]",
            self.config.anubis.metrics_bind
        )
        .unwrap();
        writeln!(output, "      interval: 30s").unwrap();
        writeln!(output, "      timeout: 10s").unwrap();
        writeln!(output, "      retries: 3").unwrap();
        writeln!(output, "      start_period: 40s").unwrap();

        // Anubis depends on the last proxy layer
        if self.config.proxies.len() > 1 {
            let last_proxy = &self.config.proxies[self.config.proxies.len() - 1];
            writeln!(output, "    depends_on:").unwrap();
            writeln!(output, "      - {}", last_proxy.name).unwrap();
        }

        Ok(())
    }

    /// Generate backend service definition
    fn generate_backend_service(
        &self,
        output: &mut String,
        service: &crate::config::ServiceConfig,
    ) -> Result<()> {
        writeln!(output).unwrap();
        writeln!(output, "  # Backend Service: {}", service.name).unwrap();
        writeln!(output, "  {}:", service.name).unwrap();
        writeln!(output, "    image: alpine:latest").unwrap();
        writeln!(output, "    container_name: {}", service.name).unwrap();
        writeln!(output, "    restart: unless-stopped").unwrap();
        writeln!(output, "    volumes:").unwrap();
        writeln!(output, "      - ./{}/config:/app/config:ro", service.name).unwrap();
        writeln!(output, "      - ./{}/data:/app/data:rw", service.name).unwrap();
        writeln!(output, "    networks:").unwrap();
        writeln!(output, "      - back-net").unwrap();
        writeln!(output, "    environment:").unwrap();
        writeln!(output, "      - SERVICE_NAME={}", service.name).unwrap();
        writeln!(output, "      - DOMAIN={}", service.domain).unwrap();
        writeln!(output, "      - UPSTREAM={}", service.upstream).unwrap();
        writeln!(output, "    labels:").unwrap();
        writeln!(output, "      - \"cerberus.service=backend\"").unwrap();
        writeln!(output, "      - \"cerberus.name={}\"", service.name).unwrap();
        writeln!(output, "      - \"cerberus.domain={}\"", service.domain).unwrap();
        writeln!(output, "    healthcheck:").unwrap();
        writeln!(
            output,
            "      test: [\"CMD\", \"curl\", \"-f\", \"{}/health\"]",
            service.upstream
        )
        .unwrap();
        writeln!(output, "      interval: 30s").unwrap();
        writeln!(output, "      timeout: 10s").unwrap();
        writeln!(output, "      retries: 3").unwrap();
        writeln!(output, "      start_period: 60s").unwrap();

        Ok(())
    }

    /// Generate networks section
    fn generate_networks(&self, output: &mut String) -> Result<()> {
        writeln!(output).unwrap();
        writeln!(output, "networks:").unwrap();
        
        // Generate networks from config
        if !self.config.networks.is_empty() {
            for (name, network) in &self.config.networks {
                writeln!(output, "  {}:", name).unwrap();
                writeln!(output, "    driver: {}", network.driver).unwrap();
                
                if !network.external {
                    writeln!(output, "    name: {}-{}", self.config.project.name, name).unwrap();
                    
                    if let Some(ipam) = &network.ipam {
                        writeln!(output, "    ipam:").unwrap();
                        if let Some(driver) = &ipam.driver {
                            writeln!(output, "      driver: {}", driver).unwrap();
                        }
                        if !ipam.config.is_empty() {
                            writeln!(output, "      config:").unwrap();
                            for config in &ipam.config {
                                writeln!(output, "        - ").unwrap();
                                if let Some(subnet) = &config.subnet {
                                    writeln!(output, "          subnet: {}", subnet).unwrap();
                                }
                                if let Some(gateway) = &config.gateway {
                                    writeln!(output, "          gateway: {}", gateway).unwrap();
                                }
                            }
                        }
                    }
                } else {
                    writeln!(output, "    external: true").unwrap();
                    if let Some(external_name) = &network.name {
                        writeln!(output, "    name: {}", external_name).unwrap();
                    }
                }
                writeln!(output).unwrap();
            }
        } else {
            // Fallback to default networks
            writeln!(output, "  front-net:").unwrap();
            writeln!(output, "    driver: bridge").unwrap();
            writeln!(output, "    name: {}-front", self.config.project.name).unwrap();
            writeln!(output, "    ipam:").unwrap();
            writeln!(output, "      config:").unwrap();
            writeln!(output, "        - subnet: 10.100.0.0/16").unwrap();
            writeln!(output).unwrap();
            writeln!(output, "  back-net:").unwrap();
            writeln!(output, "    driver: bridge").unwrap();
            writeln!(output, "    name: {}-back", self.config.project.name).unwrap();
            writeln!(output, "    ipam:").unwrap();
            writeln!(output, "      config:").unwrap();
            writeln!(output, "        - subnet: 10.101.0.0/16").unwrap();
        }

        Ok(())
    }

    /// Generate volumes section
    fn generate_volumes(&self, output: &mut String) -> Result<()> {
        writeln!(output).unwrap();
        writeln!(output, "volumes:").unwrap();
        
        // Generate volumes from config
        if !self.config.volumes.is_empty() {
            for (name, volume) in &self.config.volumes {
                writeln!(output, "  {}:", name).unwrap();
                
                if !volume.external {
                    if let Some(driver) = &volume.driver {
                        writeln!(output, "    driver: {}", driver).unwrap();
                    }
                    writeln!(output, "    name: {}-{}", self.config.project.name, name).unwrap();
                    
                    if !volume.driver_opts.is_empty() {
                        writeln!(output, "    driver_opts:").unwrap();
                        for (key, value) in &volume.driver_opts {
                            writeln!(output, "      {}: {}", key, value).unwrap();
                        }
                    }
                } else {
                    writeln!(output, "    external: true").unwrap();
                    if let Some(external_name) = &volume.name {
                        writeln!(output, "    name: {}", external_name).unwrap();
                    }
                }
                
                if !volume.labels.is_empty() {
                    writeln!(output, "    labels:").unwrap();
                    for (key, value) in &volume.labels {
                        writeln!(output, "      {}: {}", key, value).unwrap();
                    }
                }
                writeln!(output).unwrap();
            }
        } else {
            // Fallback to default volumes
            writeln!(output, "  # Persistent data volumes").unwrap();
            writeln!(output, "  postgres_data:").unwrap();
            writeln!(output, "    driver: local").unwrap();
            writeln!(output, "    name: {}-postgres", self.config.project.name).unwrap();
            writeln!(output).unwrap();
            writeln!(output, "  redis_data:").unwrap();
            writeln!(output, "    driver: local").unwrap();
            writeln!(output, "    name: {}-redis", self.config.project.name).unwrap();
            writeln!(output).unwrap();
            writeln!(output, "  # Log volumes").unwrap();
            writeln!(output, "  nginx_logs:").unwrap();
            writeln!(output, "    driver: local").unwrap();
            writeln!(output, "    name: {}-logs", self.config.project.name).unwrap();
        }

        Ok(())
    }

    /// Get Docker image for proxy type
    fn get_proxy_image(&self, proxy_type: &ProxyType) -> &'static str {
        match proxy_type {
            ProxyType::Caddy => "caddy:alpine",
            ProxyType::Nginx => "nginx:alpine",
            ProxyType::HaProxy => "haproxy:alpine",
            ProxyType::Traefik => "traefik:v3.0",
        }
    }

    /// Get configuration directory for proxy type
    fn get_proxy_config_dir(&self, proxy_type: &ProxyType) -> &'static str {
        match proxy_type {
            ProxyType::Caddy => "/etc/caddy",
            ProxyType::Nginx => "/etc/nginx",
            ProxyType::HaProxy => "/usr/local/etc/haproxy",
            ProxyType::Traefik => "/etc/traefik",
        }
    }

    /// Get healthcheck command for proxy type
    fn get_proxy_healthcheck_cmd(&self, proxy_type: &ProxyType) -> &'static str {
        match proxy_type {
            ProxyType::Caddy => "curl -f http://localhost:2019/health || exit 1",
            ProxyType::Nginx => "nginx -t || exit 1",
            ProxyType::HaProxy => "haproxy -c -f /usr/local/etc/haproxy/haproxy.cfg || exit 1",
            ProxyType::Traefik => {
                "wget --no-verbose --tries=1 --spider http://localhost:8080/ping || exit 1"
            }
        }
    }

    /// Check if upstream is an external IP/hostname
    fn is_external_upstream(&self, upstream: &str) -> bool {
        // Simple check: if it contains IP pattern or external domains
        upstream.contains("192.")
            || upstream.contains("10.")
            || upstream.contains("172.")
            || upstream.contains(".com")
            || upstream.contains(".net")
            || upstream.contains(".org")
            || upstream.contains("://")
                && !upstream.contains("://internal-")
                && !upstream.contains("http://internal-service")
    }

    /// Validate a Docker Compose file
    pub async fn validate_file(path: &std::path::Path) -> Result<()> {
        // Run docker-compose config to validate
        let output = Command::new("docker-compose")
            .arg("-f")
            .arg(path)
            .arg("config")
            .output()
            .map_err(|e| CerberusError::io(path, e))?;

        if !output.status.success() {
            let error_msg = String::from_utf8_lossy(&output.stderr);
            return Err(CerberusError::DockerComposeValidation {
                message: error_msg.to_string(),
            });
        }

        Ok(())
    }
}

impl ProxyType {
    /// Convert ProxyType to string for display
    fn to_string(&self) -> &'static str {
        match self {
            ProxyType::Caddy => "caddy",
            ProxyType::Nginx => "nginx",
            ProxyType::HaProxy => "haproxy",
            ProxyType::Traefik => "traefik",
        }
    }
}

#[cfg(test)]
mod tests;
