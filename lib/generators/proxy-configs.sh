#!/bin/bash

# Proxy Configuration Generator
# Generates proxy configurations for nginx, caddy, haproxy, and traefik

set -euo pipefail

# Source required libraries
if [[ -z "${SCRIPT_DIR:-}" ]]; then
    SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/../.." && pwd)"
fi
source "${SCRIPT_DIR}/lib/core/utils.sh"
source "${SCRIPT_DIR}/lib/core/config-simple.sh"

# =============================================================================
# CONSTANTS
# =============================================================================

readonly PROXY_CONFIG_DIR="${BUILT_DIR}/proxy-configs"

# =============================================================================
# MAIN GENERATION FUNCTION
# =============================================================================

# Generate all proxy configurations
generate_proxy_configs() {
    require_config_loaded
    
    log_info "Generating proxy configurations..."
    
    # Create proxy config directory
    safe_mkdir "$PROXY_CONFIG_DIR"
    
    # Generate configurations for each proxy
    local proxy_count
    proxy_count=$(config_get_array_table_count "proxies")
    
    if [[ $proxy_count -eq 0 ]]; then
        log_warn "No proxy configurations found"
        return 0
    fi
    
    for ((i=0; i<proxy_count; i++)); do
        generate_single_proxy_config "$i"
    done
    
    log_info "Proxy configurations generated successfully"
}

# Generate configuration for a single proxy
generate_single_proxy_config() {
    local index="$1"
    local prefix="proxies.${index}"
    
    local name type
    name=$(config_get_string "${prefix}.name")
    type=$(config_get_string "${prefix}.type")
    
    if [[ -z "$name" || -z "$type" ]]; then
        log_error "Proxy[$index]: name and type are required"
        return 1
    fi
    
    log_info "Generating $type configuration for proxy: $name"
    
    # Create proxy-specific directory
    local proxy_dir="${PROXY_CONFIG_DIR}/${name}"
    safe_mkdir "$proxy_dir"
    
    # Generate configuration based on type
    case "$type" in
        nginx)
            generate_nginx_config "$index" "$proxy_dir"
            ;;
        caddy)
            generate_caddy_config "$index" "$proxy_dir"
            ;;
        haproxy)
            generate_haproxy_config "$index" "$proxy_dir"
            ;;
        traefik)
            generate_traefik_config "$index" "$proxy_dir"
            ;;
        *)
            log_error "Unknown proxy type: $type"
            return 1
            ;;
    esac
}

# =============================================================================
# NGINX CONFIGURATION GENERATOR
# =============================================================================

# Generate nginx configuration
generate_nginx_config() {
    local index="$1"
    local output_dir="$2"
    local prefix="proxies.${index}"
    
    # Main nginx.conf
    cat > "${output_dir}/nginx.conf" << 'EOF'
# Generated by Cerberus
user nginx;
worker_processes auto;
error_log /var/log/nginx/error.log warn;
pid /var/run/nginx.pid;

events {
    worker_connections 4096;
    use epoll;
}

http {
    include /etc/nginx/mime.types;
    default_type application/octet-stream;

    # Logging
    log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                    '$status $body_bytes_sent "$http_referer" '
                    '"$http_user_agent" "$http_x_forwarded_for"';
    
    access_log /var/log/nginx/access.log main;

    # Performance
    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    keepalive_timeout 65;
    types_hash_max_size 2048;
    
    # Security
    server_tokens off;
    
    # Gzip
    gzip on;
    gzip_vary on;
    gzip_proxied any;
    gzip_comp_level 6;
    gzip_types text/plain text/css text/xml text/javascript application/json application/javascript application/xml+rss application/rss+xml application/atom+xml image/svg+xml;

    # Include additional configurations
    include /etc/nginx/conf.d/*.conf;
}
EOF

    # Generate conf.d directory
    safe_mkdir "${output_dir}/conf.d"
    
    # Generate server configurations
    generate_nginx_servers "$index" "${output_dir}/conf.d"
}

# Generate nginx server blocks
generate_nginx_servers() {
    local index="$1"
    local conf_dir="$2"
    local prefix="proxies.${index}"
    
    # Get proxy configuration
    local name upstream internal_port
    name=$(config_get_string "${prefix}.name")
    upstream=$(config_get_string "${prefix}.upstream" "")
    internal_port=$(config_get_int "${prefix}.internal_port" 80)
    
    # Default server block
    cat > "${conf_dir}/default.conf" << EOF
# Default server configuration
server {
    listen ${internal_port} default_server;
    listen [::]:${internal_port} default_server;
    server_name _;
    
    # Health check endpoint
    location /health {
        access_log off;
        return 200 "healthy\\n";
        add_header Content-Type text/plain;
    }
    
    # Default location
    location / {
        return 444;
    }
}
EOF

    # Generate service-specific server blocks
    local service_count
    service_count=$(config_get_array_table_count "services")
    
    for ((j=0; j<service_count; j++)); do
        generate_nginx_service_config "$j" "$conf_dir" "$internal_port"
    done
}

# Generate nginx configuration for a service
generate_nginx_service_config() {
    local service_index="$1"
    local conf_dir="$2"
    local listen_port="$3"
    local prefix="services.${service_index}"
    
    local name domain upstream websocket compress max_body_size
    name=$(config_get_string "${prefix}.name")
    domain=$(config_get_string "${prefix}.domain")
    upstream=$(config_get_string "${prefix}.upstream")
    websocket=$(config_get_bool "${prefix}.websocket")
    compress=$(config_get_bool "${prefix}.compress" "true")
    max_body_size=$(config_get_string "${prefix}.max_body_size" "1m")
    
    if [[ -z "$name" || -z "$domain" || -z "$upstream" ]]; then
        return 0
    fi
    
    cat > "${conf_dir}/${name}.conf" << EOF
# Configuration for ${name} (${domain})
upstream ${name}_backend {
    server ${upstream#http://};
    keepalive 32;
}

server {
    listen ${listen_port};
    listen [::]:${listen_port};
    server_name ${domain};
    
    # Security headers
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;
    
    # Max body size
    client_max_body_size ${max_body_size};
EOF

    # Add compression if enabled
    if [[ "$compress" == "true" ]]; then
        cat >> "${conf_dir}/${name}.conf" << 'EOF'
    
    # Compression
    gzip on;
    gzip_vary on;
    gzip_min_length 1024;
    gzip_proxied any;
    gzip_types text/plain text/css text/xml text/javascript application/json application/javascript application/xml+rss application/rss+xml application/atom+xml image/svg+xml;
EOF
    fi
    
    # Add main location block
    cat >> "${conf_dir}/${name}.conf" << EOF
    
    location / {
        proxy_pass http://${name}_backend;
        proxy_http_version 1.1;
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
EOF

    # Add WebSocket support if enabled
    if [[ "$websocket" == "true" ]]; then
        cat >> "${conf_dir}/${name}.conf" << 'EOF'
        
        # WebSocket support
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_read_timeout 86400;
EOF
    fi
    
    cat >> "${conf_dir}/${name}.conf" << 'EOF'
    }
}
EOF
}

# =============================================================================
# CADDY CONFIGURATION GENERATOR
# =============================================================================

# Generate Caddy configuration
generate_caddy_config() {
    local index="$1"
    local output_dir="$2"
    local prefix="proxies.${index}"
    
    # Get proxy configuration
    local name internal_port
    name=$(config_get_string "${prefix}.name")
    internal_port=$(config_get_int "${prefix}.internal_port" 80)
    
    # Generate Caddyfile
    cat > "${output_dir}/Caddyfile" << EOF
# Generated by Cerberus
# Global options
{
    admin :2019
    auto_https off
}

# Default response for unmatched requests
:${internal_port} {
    respond /health "healthy" 200
    respond 404
}
EOF

    # Generate service configurations
    local service_count
    service_count=$(config_get_array_table_count "services")
    
    for ((j=0; j<service_count; j++)); do
        generate_caddy_service_config "$j" "${output_dir}/Caddyfile" "$internal_port"
    done
}

# Generate Caddy configuration for a service
generate_caddy_service_config() {
    local service_index="$1"
    local caddyfile="$2"
    local listen_port="$3"
    local prefix="services.${service_index}"
    
    local name domain upstream websocket compress max_body_size
    name=$(config_get_string "${prefix}.name")
    domain=$(config_get_string "${prefix}.domain")
    upstream=$(config_get_string "${prefix}.upstream")
    websocket=$(config_get_bool "${prefix}.websocket")
    compress=$(config_get_bool "${prefix}.compress" "true")
    max_body_size=$(config_get_string "${prefix}.max_body_size" "1m")
    
    if [[ -z "$name" || -z "$domain" || -z "$upstream" ]]; then
        return 0
    fi
    
    cat >> "$caddyfile" << EOF

# ${name} - ${domain}
${domain}:${listen_port} {
    # Logging
    log {
        output file /var/log/caddy/${name}_access.log
        format json
    }
    
    # Headers
    header {
        X-Frame-Options "SAMEORIGIN"
        X-Content-Type-Options "nosniff"
        X-XSS-Protection "1; mode=block"
        -Server
    }
EOF

    # Add compression if enabled
    if [[ "$compress" == "true" ]]; then
        echo "    encode gzip zstd" >> "$caddyfile"
    fi
    
    # Add reverse proxy
    echo "    reverse_proxy ${upstream} {" >> "$caddyfile"
    echo "        header_up Host {host}" >> "$caddyfile"
    echo "        header_up X-Real-IP {remote}" >> "$caddyfile"
    echo "        header_up X-Forwarded-For {remote}" >> "$caddyfile"
    echo "        header_up X-Forwarded-Proto {scheme}" >> "$caddyfile"
    
    # Add custom request headers
    if [[ -n "$(config_get_string "${prefix}.headers_request_host")" ]]; then
        echo "        header_up Host \"$(config_get_string "${prefix}.headers_request_host")\"" >> "$caddyfile"
    fi
    if [[ -n "$(config_get_string "${prefix}.headers_request_x_forwarded_proto")" ]]; then
        echo "        header_up X-Forwarded-Proto \"$(config_get_string "${prefix}.headers_request_x_forwarded_proto")\"" >> "$caddyfile"
    fi
    if [[ "$(config_get_string "${prefix}.headers_request_proxy")" == "" ]]; then
        echo "        header_up -Proxy" >> "$caddyfile"
    fi
    
    if [[ "$websocket" == "true" ]]; then
        echo "        # WebSocket support" >> "$caddyfile"
        echo "        header_up Upgrade {http.request.header.Upgrade}" >> "$caddyfile"
        echo "        header_up Connection {http.request.header.Connection}" >> "$caddyfile"
    fi
    
    echo "    }" >> "$caddyfile"
    
    # Add custom response headers
    local has_response_headers=false
    if [[ -n "$(config_get_string "${prefix}.headers_response_cache_control")" ]]; then
        if [[ "$has_response_headers" == "false" ]]; then
            echo "    header {" >> "$caddyfile"
            has_response_headers=true
        fi
        echo "        Cache-Control \"$(config_get_string "${prefix}.headers_response_cache_control")\"" >> "$caddyfile"
    fi
    if [[ -n "$(config_get_string "${prefix}.headers_response_pragma")" ]]; then
        if [[ "$has_response_headers" == "false" ]]; then
            echo "    header {" >> "$caddyfile"
            has_response_headers=true
        fi
        echo "        Pragma \"$(config_get_string "${prefix}.headers_response_pragma")\"" >> "$caddyfile"
    fi
    if [[ "$has_response_headers" == "true" ]]; then
        echo "    }" >> "$caddyfile"
    fi
    echo "}" >> "$caddyfile"
}

# =============================================================================
# HAPROXY CONFIGURATION GENERATOR
# =============================================================================

# Generate HAProxy configuration
generate_haproxy_config() {
    local index="$1"
    local output_dir="$2"
    local prefix="proxies.${index}"
    
    # Get proxy configuration
    local name internal_port max_connections
    name=$(config_get_string "${prefix}.name")
    internal_port=$(config_get_int "${prefix}.internal_port" 80)
    max_connections=$(config_get_int "${prefix}.max_connections" 1024)
    
    # Generate haproxy.cfg
    cat > "${output_dir}/haproxy.cfg" << EOF
# Generated by Cerberus
global
    log stdout local0
    maxconn ${max_connections}
    user haproxy
    group haproxy
    daemon
    
    # Security
    tune.ssl.default-dh-param 2048
    ssl-default-bind-ciphers ECDHE+AESGCM:ECDHE+AES256:ECDHE+AES128:!PSK:!DHE:!RSA:!DSS:!aNull:!MD5
    ssl-default-bind-options no-sslv3 no-tlsv10 no-tlsv11

defaults
    log     global
    mode    http
    option  httplog
    option  dontlognull
    option  forwardfor
    timeout connect 5s
    timeout client  30s
    timeout server  30s
    
    # Enable stats
    stats enable
    stats uri /haproxy?stats
    stats refresh 30s

# Frontend
frontend http_front
    bind *:${internal_port}
    
    # Health check
    acl is_health path /health
    use_backend health_backend if is_health
    
    # Service routing
EOF

    # Generate ACLs and backend uses
    local service_count
    service_count=$(config_get_array_table_count "services")
    
    for ((j=0; j<service_count; j++)); do
        local service_prefix="services.${j}"
        local service_name service_domain
        service_name=$(config_get_string "${service_prefix}.name")
        service_domain=$(config_get_string "${service_prefix}.domain")
        
        if [[ -n "$service_name" && -n "$service_domain" ]]; then
            echo "    acl is_${service_name} hdr(host) -i ${service_domain}" >> "${output_dir}/haproxy.cfg"
            echo "    use_backend ${service_name}_backend if is_${service_name}" >> "${output_dir}/haproxy.cfg"
        fi
    done
    
    echo "    default_backend no_match" >> "${output_dir}/haproxy.cfg"
    
    # Generate backends
    generate_haproxy_backends "$index" "${output_dir}/haproxy.cfg"
}

# Generate HAProxy backends
generate_haproxy_backends() {
    local index="$1"
    local config_file="$2"
    
    # Health check backend
    cat >> "$config_file" << 'EOF'

# Health check backend
backend health_backend
    http-request return status 200 content-type text/plain string "healthy\n"

# Default backend
backend no_match
    http-request return status 404
EOF
    
    # Service backends
    local service_count
    service_count=$(config_get_array_table_count "services")
    
    for ((j=0; j<service_count; j++)); do
        generate_haproxy_service_backend "$j" "$config_file"
    done
}

# Generate HAProxy backend for a service
generate_haproxy_service_backend() {
    local service_index="$1"
    local config_file="$2"
    local prefix="services.${service_index}"
    
    local name upstream websocket compress
    name=$(config_get_string "${prefix}.name")
    upstream=$(config_get_string "${prefix}.upstream")
    websocket=$(config_get_bool "${prefix}.websocket")
    compress=$(config_get_bool "${prefix}.compress" "true")
    
    if [[ -z "$name" || -z "$upstream" ]]; then
        return 0
    fi
    
    # Extract host and port from upstream
    local upstream_host upstream_port
    if [[ "$upstream" =~ ^https?://([^:/]+):?([0-9]+)?/?.*$ ]]; then
        upstream_host="${BASH_REMATCH[1]}"
        upstream_port="${BASH_REMATCH[2]:-80}"
    else
        return 0
    fi
    
    cat >> "$config_file" << EOF

# Backend for ${name}
backend ${name}_backend
    balance roundrobin
    option httpchk GET /health
EOF

    if [[ "$compress" == "true" ]]; then
        echo "    compression algo gzip" >> "$config_file"
        echo "    compression type text/html text/plain text/css text/javascript application/json" >> "$config_file"
    fi
    
    if [[ "$websocket" == "true" ]]; then
        echo "    # WebSocket support" >> "$config_file"
        echo "    option http-server-close" >> "$config_file"
        echo "    timeout tunnel 1h" >> "$config_file"
    fi
    
    echo "    server ${name}1 ${upstream_host}:${upstream_port} check" >> "$config_file"
}

# =============================================================================
# TRAEFIK CONFIGURATION GENERATOR
# =============================================================================

# Generate Traefik configuration
generate_traefik_config() {
    local index="$1"
    local output_dir="$2"
    local prefix="proxies.${index}"
    
    # Get proxy configuration
    local name internal_port
    name=$(config_get_string "${prefix}.name")
    internal_port=$(config_get_int "${prefix}.internal_port" 80)
    
    # Generate static configuration (traefik.yml)
    cat > "${output_dir}/traefik.yml" << EOF
# Generated by Cerberus
# Static configuration

# API and dashboard
api:
  dashboard: true
  debug: true

# Entry points
entryPoints:
  web:
    address: ":${internal_port}"

# Providers
providers:
  file:
    directory: /etc/traefik/dynamic
    watch: true

# Logging
log:
  level: INFO
  format: json

accessLog:
  format: json
  filePath: /var/log/traefik/access.log

# Metrics
metrics:
  prometheus:
    addEntryPointsLabels: true
    addServicesLabels: true

# Health check
ping:
  entryPoint: web
EOF

    # Create dynamic configuration directory
    safe_mkdir "${output_dir}/dynamic"
    
    # Generate dynamic configuration
    generate_traefik_dynamic_config "$index" "${output_dir}/dynamic"
}

# Generate Traefik dynamic configuration
generate_traefik_dynamic_config() {
    local index="$1"
    local dynamic_dir="$2"
    
    # Start dynamic configuration
    cat > "${dynamic_dir}/config.yml" << 'EOF'
# Generated by Cerberus
# Dynamic configuration

http:
  routers:
    # Health check router
    health:
      rule: "Path(`/health`)"
      service: health-service
      priority: 1000
EOF
    
    # Generate service routers
    local service_count
    service_count=$(config_get_array_table_count "services")
    
    for ((j=0; j<service_count; j++)); do
        generate_traefik_service_router "$j" "${dynamic_dir}/config.yml"
    done
    
    # Services section
    echo "  services:" >> "${dynamic_dir}/config.yml"
    echo "    # Health service" >> "${dynamic_dir}/config.yml"
    echo "    health-service:" >> "${dynamic_dir}/config.yml"
    echo "      loadBalancer:" >> "${dynamic_dir}/config.yml"
    echo "        servers:" >> "${dynamic_dir}/config.yml"
    echo "          - url: \"http://localhost\"" >> "${dynamic_dir}/config.yml"
    
    # Generate service definitions
    for ((j=0; j<service_count; j++)); do
        generate_traefik_service_definition "$j" "${dynamic_dir}/config.yml"
    done
    
    # Middlewares section
    echo "  middlewares:" >> "${dynamic_dir}/config.yml"
    echo "    # Security headers" >> "${dynamic_dir}/config.yml"
    echo "    security-headers:" >> "${dynamic_dir}/config.yml"
    echo "      headers:" >> "${dynamic_dir}/config.yml"
    echo "        frameDeny: true" >> "${dynamic_dir}/config.yml"
    echo "        contentTypeNosniff: true" >> "${dynamic_dir}/config.yml"
    echo "        browserXssFilter: true" >> "${dynamic_dir}/config.yml"
    echo "        customResponseHeaders:" >> "${dynamic_dir}/config.yml"
    echo "          X-Frame-Options: \"SAMEORIGIN\"" >> "${dynamic_dir}/config.yml"
}

# Generate Traefik router for a service
generate_traefik_service_router() {
    local service_index="$1"
    local config_file="$2"
    local prefix="services.${service_index}"
    
    local name domain
    name=$(config_get_string "${prefix}.name")
    domain=$(config_get_string "${prefix}.domain")
    
    if [[ -z "$name" || -z "$domain" ]]; then
        return 0
    fi
    
    cat >> "$config_file" << EOF
    # Router for ${name}
    ${name}:
      rule: "Host(\`${domain}\`)"
      service: ${name}-service
      middlewares:
        - security-headers
EOF
}

# Generate Traefik service definition
generate_traefik_service_definition() {
    local service_index="$1"
    local config_file="$2"
    local prefix="services.${service_index}"
    
    local name upstream
    name=$(config_get_string "${prefix}.name")
    upstream=$(config_get_string "${prefix}.upstream")
    
    if [[ -z "$name" || -z "$upstream" ]]; then
        return 0
    fi
    
    cat >> "$config_file" << EOF
    # Service ${name}
    ${name}-service:
      loadBalancer:
        servers:
          - url: "${upstream}"
        passHostHeader: true
EOF
}

# =============================================================================
# UTILITY FUNCTIONS
# =============================================================================

# Validate generated configurations
validate_proxy_configs() {
    log_info "Validating proxy configurations..."
    
    # Check if proxy config directory exists
    if [[ ! -d "$PROXY_CONFIG_DIR" ]]; then
        log_error "Proxy configuration directory not found: $PROXY_CONFIG_DIR"
        return 1
    fi
    
    # Validate each proxy configuration
    local errors=0
    for proxy_dir in "$PROXY_CONFIG_DIR"/*; do
        if [[ ! -d "$proxy_dir" ]]; then
            continue
        fi
        
        local proxy_name
        proxy_name=$(basename "$proxy_dir")
        
        # Check for required files based on proxy type
        if [[ -f "$proxy_dir/nginx.conf" ]]; then
            log_info "Validating nginx configuration for $proxy_name"
            # Basic file existence check
            if [[ ! -d "$proxy_dir/conf.d" ]]; then
                log_error "Missing conf.d directory for nginx proxy $proxy_name"
                ((errors++))
            fi
        elif [[ -f "$proxy_dir/Caddyfile" ]]; then
            log_info "Validating Caddy configuration for $proxy_name"
            # Caddyfile should exist
        elif [[ -f "$proxy_dir/haproxy.cfg" ]]; then
            log_info "Validating HAProxy configuration for $proxy_name"
            # haproxy.cfg should exist
        elif [[ -f "$proxy_dir/traefik.yml" ]]; then
            log_info "Validating Traefik configuration for $proxy_name"
            if [[ ! -d "$proxy_dir/dynamic" ]]; then
                log_error "Missing dynamic directory for Traefik proxy $proxy_name"
                ((errors++))
            fi
        else
            log_error "No recognized proxy configuration found for $proxy_name"
            ((errors++))
        fi
    done
    
    if [[ $errors -eq 0 ]]; then
        log_info "All proxy configurations validated successfully"
        return 0
    else
        log_error "Proxy configuration validation failed with $errors errors"
        return 1
    fi
}

# =============================================================================
# INITIALIZATION
# =============================================================================

# Initialize generator
if [[ "${BASH_SOURCE[0]}" != "${0}" ]]; then
    log_debug "Proxy configuration generator loaded"
fi