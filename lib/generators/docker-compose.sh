#!/bin/bash

# Docker Compose Generator
# Generates docker-compose.yaml from config.toml

set -euo pipefail

# Source required libraries
if [[ -z "${SCRIPT_DIR:-}" ]]; then
    SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/../.." && pwd)"
fi
source "${SCRIPT_DIR}/lib/core/utils.sh"
source "${SCRIPT_DIR}/lib/core/config-simple.sh"

# =============================================================================
# CONSTANTS AND TEMPLATES
# =============================================================================

readonly COMPOSE_VERSION="3.8"
readonly DEFAULT_RESTART_POLICY="unless-stopped"

# =============================================================================
# DOCKER COMPOSE GENERATION FUNCTIONS
# =============================================================================

# Generate complete docker-compose.yaml
generate_docker_compose() {
    local output_file="${1:-${BUILT_DIR}/docker-compose.yaml}"
    
    require_config_loaded
    
    log_info "Generating Docker Compose configuration..."
    
    # Ensure output directory exists
    safe_mkdir "$(dirname "$output_file")"
    
    # Generate docker-compose content
    {
        generate_compose_header
        echo
        generate_compose_services
        echo
        generate_compose_networks
        echo
        generate_compose_volumes
    } > "$output_file"
    
    log_info "Docker Compose configuration generated: $output_file"
    return 0
}

# Generate compose file header
generate_compose_header() {
    cat << EOF
version: '${COMPOSE_VERSION}'

# Generated by Cerberus $(date -u +"%Y-%m-%d %H:%M:%S UTC")
# Project: $(config_get_string "project.name" "cerberus")
# Configuration: $(basename "$CONFIG_FILE_PATH")
EOF
}

# Generate services section
generate_compose_services() {
    echo "services:"
    
    # Generate proxy services
    generate_proxy_services
    
    # Generate Anubis DDoS protection if enabled
    if config_get_bool "anubis.enabled" false; then
        generate_anubis_service
    fi
    
    # Generate backend services
    generate_backend_services
}

# Generate proxy services
generate_proxy_services() {
    local proxy_count
    proxy_count=$(config_get_array_table_count "proxies")
    
    if [[ $proxy_count -eq 0 ]]; then
        log_warn "No proxy configurations found"
        return 0
    fi
    
    for ((i=0; i<proxy_count; i++)); do
        generate_single_proxy_service "$i"
    done
}

# Generate single proxy service
generate_single_proxy_service() {
    local index="$1"
    local prefix="proxies.${index}"
    
    local name type external_port internal_port instances upstream
    name=$(config_get_string "${prefix}.name")
    type=$(config_get_string "${prefix}.type")
    external_port=$(config_get_int "${prefix}.external_port" 8080)
    internal_port=$(config_get_int "${prefix}.internal_port" 80)
    instances=$(config_get_int "${prefix}.instances" 1)
    upstream=$(config_get_string "${prefix}.upstream" "")
    
    if [[ -z "$name" || -z "$type" ]]; then
        log_error "Proxy[$index]: name and type are required"
        return 1
    fi
    
    cat << EOF

  # Proxy Layer: $name ($type)
  ${name}:
    image: $(get_proxy_image "$type")
    container_name: ${name}
    restart: ${DEFAULT_RESTART_POLICY}
    ports:
      - "${external_port}:${internal_port}"
    volumes:
      - ./proxy-configs/${name}:/etc/$(get_proxy_config_dir "$type"):ro
      - ./built/logs:/var/log/nginx:rw
    networks:
      - front-net
      - back-net
    depends_on:
$(generate_proxy_dependencies "$index")
    environment:
$(generate_proxy_environment "$index")
    labels:
      - "cerberus.service=proxy"
      - "cerberus.layer=${index}"
      - "cerberus.type=${type}"
    healthcheck:
      test: ["CMD", "$(get_proxy_healthcheck_cmd "$type")"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
EOF

    # Generate scaled instances if more than 1
    if [[ $instances -gt 1 ]]; then
        for ((j=2; j<=instances; j++)); do
            generate_scaled_proxy_instance "$name" "$j" "$type" "$internal_port"
        done
    fi
}

# Generate scaled proxy instance
generate_scaled_proxy_instance() {
    local base_name="$1"
    local instance="$2"
    local type="$3"
    local internal_port="$4"
    
    cat << EOF

  ${base_name}-${instance}:
    image: $(get_proxy_image "$type")
    container_name: ${base_name}-${instance}
    restart: ${DEFAULT_RESTART_POLICY}
    volumes:
      - ./proxy-configs/${base_name}:/etc/$(get_proxy_config_dir "$type"):ro
      - ./built/logs:/var/log/nginx:rw
    networks:
      - back-net
    environment:
      - INSTANCE_ID=${instance}
    labels:
      - "cerberus.service=proxy"
      - "cerberus.instance=${instance}"
      - "cerberus.type=${type}"
    healthcheck:
      test: ["CMD", "$(get_proxy_healthcheck_cmd "$type")"]
      interval: 30s
      timeout: 10s
      retries: 3
EOF
}

# Generate Anubis DDoS protection service
generate_anubis_service() {
    local bind difficulty target metrics_bind
    bind=$(config_get_string "anubis.bind" ":8080")
    difficulty=$(config_get_int "anubis.difficulty" 5)
    target=$(config_get_string "anubis.target" "http://proxy-2:80")
    metrics_bind=$(config_get_string "anubis.metrics_bind" ":9090")
    
    cat << EOF

  # DDoS Protection Layer
  anubis:
    image: chaitin/anubis:latest
    container_name: anubis
    restart: ${DEFAULT_RESTART_POLICY}
    ports:
      - "8080:8080"
      - "9090:9090"
    volumes:
      - ./anubis/botPolicy.json:/app/botPolicy.json:ro
      - ./built/logs:/var/log/anubis:rw
    networks:
      - front-net
      - back-net
    environment:
      - BIND=${bind}
      - DIFFICULTY=${difficulty}
      - TARGET=${target}
      - METRICS_BIND=${metrics_bind}
      - SERVE_ROBOTS_TXT=true
    labels:
      - "cerberus.service=ddos-protection"
      - "cerberus.layer=anubis"
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:9090/metrics"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    depends_on:
      - proxy-2
EOF
}

# Generate backend services
generate_backend_services() {
    local service_count
    service_count=$(config_get_array_table_count "services")
    
    if [[ $service_count -eq 0 ]]; then
        log_warn "No backend service configurations found"
        return 0
    fi
    
    for ((i=0; i<service_count; i++)); do
        generate_backend_service "$i"
    done
}

# Generate single backend service
generate_backend_service() {
    local index="$1"
    local prefix="services.${index}"
    
    local name domain upstream websocket compress max_body_size
    name=$(config_get_string "${prefix}.name")
    domain=$(config_get_string "${prefix}.domain")
    upstream=$(config_get_string "${prefix}.upstream")
    websocket=$(config_get_bool "${prefix}.websocket" false)
    compress=$(config_get_bool "${prefix}.compress" true)
    max_body_size=$(config_get_string "${prefix}.max_body_size" "1m")
    
    if [[ -z "$name" || -z "$domain" || -z "$upstream" ]]; then
        log_error "Service[$index]: name, domain, and upstream are required"
        return 1
    fi
    
    # Extract host and port from upstream URL
    local upstream_host upstream_port
    if [[ "$upstream" =~ ^https?://([^:/]+):?([0-9]+)?/?.*$ ]]; then
        upstream_host="${BASH_REMATCH[1]}"
        upstream_port="${BASH_REMATCH[2]:-$(if [[ "$upstream" =~ ^https ]]; then echo "443"; else echo "80"; fi)}"
    else
        log_error "Service[$index]: invalid upstream URL: $upstream"
        return 1
    fi
    
    # Only generate service if it's a local container (not external IP)
    if [[ "$upstream_host" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
        # External IP - no container needed
        return 0
    fi
    
    cat << EOF

  # Backend Service: $name
  ${name}:
    image: $(get_service_image "$name")
    container_name: ${name}
    restart: ${DEFAULT_RESTART_POLICY}
    volumes:
$(generate_service_volumes "$name")
    networks:
      - back-net
    environment:
$(generate_service_environment "$index")
    labels:
      - "cerberus.service=backend"
      - "cerberus.name=${name}"
      - "cerberus.domain=${domain}"
    healthcheck:
      test: ["CMD", "curl", "-f", "${upstream}/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
EOF
}

# Generate compose networks section
generate_compose_networks() {
    cat << EOF
networks:
  front-net:
    driver: bridge
    name: cerberus-front
    ipam:
      config:
        - subnet: 172.20.0.0/16
  
  back-net:
    driver: bridge  
    name: cerberus-back
    ipam:
      config:
        - subnet: 172.21.0.0/16
EOF
}

# Generate compose volumes section
generate_compose_volumes() {
    cat << EOF
volumes:
  # Persistent data volumes
  postgres_data:
    driver: local
    name: cerberus-postgres
  
  redis_data:
    driver: local
    name: cerberus-redis
    
  # Log volumes
  nginx_logs:
    driver: local
    name: cerberus-logs
EOF
}

# =============================================================================
# HELPER FUNCTIONS
# =============================================================================

# Get Docker image for proxy type
get_proxy_image() {
    local type="$1"
    
    case "$type" in
        nginx)
            echo "nginx:stable-alpine"
            ;;
        caddy)
            echo "caddy:alpine"
            ;;
        haproxy)
            echo "haproxy:alpine"
            ;;
        traefik)
            echo "traefik:latest"
            ;;
        *)
            log_error "Unknown proxy type: $type"
            echo "nginx:stable-alpine"
            ;;
    esac
}

# Get proxy configuration directory
get_proxy_config_dir() {
    local type="$1"
    
    case "$type" in
        nginx)
            echo "nginx"
            ;;
        caddy)
            echo "caddy"
            ;;
        haproxy)
            echo "haproxy"
            ;;
        traefik)
            echo "traefik"
            ;;
        *)
            echo "nginx"
            ;;
    esac
}

# Get proxy healthcheck command
get_proxy_healthcheck_cmd() {
    local type="$1"
    
    case "$type" in
        nginx)
            echo "curl -f http://localhost/health || exit 1"
            ;;
        caddy)
            echo "curl -f http://localhost:2019/health || exit 1"
            ;;
        haproxy)
            echo "curl -f http://localhost:8404/stats || exit 1"
            ;;
        traefik)
            echo "curl -f http://localhost:8080/ping || exit 1"
            ;;
        *)
            echo "curl -f http://localhost/ || exit 1"
            ;;
    esac
}

# Generate proxy dependencies
generate_proxy_dependencies() {
    local index="$1"
    local dependencies=()
    
    # For the first proxy, it might depend on Anubis
    if [[ $index -eq 0 ]] && [[ "$(config_get_bool "anubis.enabled")" == "true" ]]; then
        dependencies+=("anubis")
    fi
    
    # Additional dependencies based on configuration
    local upstream
    upstream=$(config_get_string "proxies.${index}.upstream" "")
    if [[ -n "$upstream" && ! "$upstream" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+: ]]; then
        # It's a service name, not an IP
        local service_name
        service_name=$(echo "$upstream" | sed 's|.*://||' | cut -d: -f1)
        if [[ "$service_name" != "anubis" ]] || [[ ${#dependencies[@]} -eq 0 ]]; then
            dependencies+=("$service_name")
        fi
    fi
    
    # Output dependencies
    for dep in "${dependencies[@]}"; do
        echo "      - $dep"
    done
}

# Generate proxy environment variables
generate_proxy_environment() {
    local index="$1"
    local prefix="proxies.${index}"
    
    cat << EOF
      - PROXY_LAYER=${index}
      - UPSTREAM=$(config_get_string "${prefix}.upstream" "")
      - MAX_CONNECTIONS=$(config_get_int "${prefix}.max_connections" 1024)
EOF
}

# Generate service volumes
generate_service_volumes() {
    local name="$1"
    
    case "$name" in
        misskey)
            cat << EOF
      - ./misskey/config:/misskey/.config:ro
      - ./misskey/files:/misskey/files:rw
      - postgres_data:/var/lib/postgresql/data
      - redis_data:/data
EOF
            ;;
        media-proxy)
            cat << EOF
      - ./media-proxy/config:/app/config:ro
      - ./media-proxy/cache:/app/cache:rw
EOF
            ;;
        *)
            cat << EOF
      - ./${name}/config:/app/config:ro
      - ./${name}/data:/app/data:rw
EOF
            ;;
    esac
}

# Generate service environment variables
generate_service_environment() {
    local index="$1"
    local prefix="services.${index}"
    local name
    name=$(config_get_string "${prefix}.name")
    
    cat << EOF
      - SERVICE_NAME=${name}
      - DOMAIN=$(config_get_string "${prefix}.domain")
      - UPSTREAM=$(config_get_string "${prefix}.upstream")
EOF
}

# Get Docker image for service
get_service_image() {
    local name="$1"
    
    case "$name" in
        misskey)
            echo "misskey/misskey:latest"
            ;;
        media-proxy)
            echo "ghcr.io/misskey-dev/media-proxy:latest"
            ;;
        summaly)
            echo "ghcr.io/misskey-dev/summaly:latest"
            ;;
        postgres)
            echo "postgres:14-alpine"
            ;;
        redis)
            echo "redis:7-alpine"
            ;;
        *)
            echo "alpine:latest"
            ;;
    esac
}

# =============================================================================
# VALIDATION FUNCTIONS
# =============================================================================

# Validate generated docker-compose.yaml
validate_docker_compose() {
    local compose_file="${1:-${BUILT_DIR}/docker-compose.yaml}"
    
    if [[ ! -f "$compose_file" ]]; then
        log_error "Docker Compose file not found: $compose_file"
        return 1
    fi
    
    log_info "Validating Docker Compose configuration..."
    
    # Check syntax with docker-compose
    if command -v docker-compose >/dev/null 2>&1; then
        if docker-compose -f "$compose_file" config >/dev/null 2>&1; then
            log_info "Docker Compose syntax validation passed"
        else
            log_error "Docker Compose syntax validation failed"
            return 1
        fi
    elif command -v docker >/dev/null 2>&1 && docker compose version >/dev/null 2>&1; then
        if docker compose -f "$compose_file" config >/dev/null 2>&1; then
            log_info "Docker Compose syntax validation passed"
        else
            log_error "Docker Compose syntax validation failed"
            return 1
        fi
    else
        log_warn "Docker Compose not available, skipping syntax validation"
    fi
    
    return 0
}

# =============================================================================
# INITIALIZATION
# =============================================================================

# Initialize generator
if [[ "${BASH_SOURCE[0]}" != "${0}" ]]; then
    log_debug "Docker Compose generator loaded"
fi