#!/bin/bash

# Dockerfile Generator
# Generates Dockerfiles for proxy services

set -euo pipefail

# Source required libraries
if [[ -z "${SCRIPT_DIR:-}" ]]; then
    SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/../.." && pwd)"
fi
source "${SCRIPT_DIR}/lib/core/utils.sh"
source "${SCRIPT_DIR}/lib/core/config-simple.sh"

# =============================================================================
# CONSTANTS
# =============================================================================

readonly DOCKERFILE_DIR="${BUILT_DIR}/dockerfiles"

# =============================================================================
# MAIN GENERATION FUNCTION
# =============================================================================

# Generate all Dockerfiles
generate_dockerfiles() {
    require_config_loaded
    
    log_info "Generating Dockerfiles..."
    
    # Create dockerfile directory
    safe_mkdir "$DOCKERFILE_DIR"
    
    # Generate Dockerfiles for each proxy
    local proxy_count
    proxy_count=$(config_get_array_table_count "proxies")
    
    if [[ $proxy_count -eq 0 ]]; then
        log_warn "No proxy configurations found"
        return 0
    fi
    
    for ((i=0; i<proxy_count; i++)); do
        generate_proxy_dockerfile "$i"
    done
    
    # Generate Anubis Dockerfile if enabled
    if [[ "$(config_get_bool "anubis.enabled")" == "true" ]]; then
        generate_anubis_dockerfile
    fi
    
    log_info "Dockerfiles generated successfully"
}

# Generate Dockerfile for a single proxy
generate_proxy_dockerfile() {
    local index="$1"
    local prefix="proxies.${index}"
    
    local name type
    name=$(config_get_string "${prefix}.name")
    type=$(config_get_string "${prefix}.type")
    
    if [[ -z "$name" || -z "$type" ]]; then
        log_error "Proxy[$index]: name and type are required"
        return 1
    fi
    
    log_info "Generating Dockerfile for proxy: $name ($type)"
    
    # Create proxy-specific directory
    local proxy_dir="${DOCKERFILE_DIR}/${name}"
    safe_mkdir "$proxy_dir"
    
    # Generate Dockerfile based on type
    case "$type" in
        nginx)
            generate_nginx_dockerfile "$name" "$proxy_dir"
            ;;
        caddy)
            generate_caddy_dockerfile "$name" "$proxy_dir"
            ;;
        haproxy)
            generate_haproxy_dockerfile "$name" "$proxy_dir"
            ;;
        traefik)
            generate_traefik_dockerfile "$name" "$proxy_dir"
            ;;
        *)
            log_error "Unknown proxy type: $type"
            return 1
            ;;
    esac
}

# =============================================================================
# NGINX DOCKERFILE
# =============================================================================

generate_nginx_dockerfile() {
    local name="$1"
    local output_dir="$2"
    
    cat > "${output_dir}/Dockerfile" << 'EOF'
# Generated by Cerberus
FROM nginx:stable-alpine

# Install additional packages
RUN apk add --no-cache \
    bash \
    curl \
    openssl \
    logrotate \
    shadow \
    && rm -rf /var/cache/apk/*

# Create nginx user if not exists
RUN id nginx || useradd -r -g nginx -s /bin/false nginx

# Create required directories
RUN mkdir -p /var/log/nginx /var/cache/nginx \
    && chown -R nginx:nginx /var/log/nginx /var/cache/nginx

# Copy configuration files
COPY nginx.conf /etc/nginx/nginx.conf
COPY conf.d/ /etc/nginx/conf.d/

# Copy custom entrypoint if needed
COPY entrypoint.sh /docker-entrypoint.sh
RUN chmod +x /docker-entrypoint.sh

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
    CMD curl -f http://localhost/health || exit 1

# Expose ports
EXPOSE 80 443

# Run as nginx user
USER nginx

ENTRYPOINT ["/docker-entrypoint.sh"]
CMD ["nginx", "-g", "daemon off;"]
EOF

    # Generate entrypoint script
    cat > "${output_dir}/entrypoint.sh" << 'EOF'
#!/bin/bash
# Generated by Cerberus

set -e

# Environment variable substitution in config files
if [[ -n "${UPSTREAM}" ]]; then
    find /etc/nginx/conf.d -name "*.conf" -exec sed -i "s|http://backend|${UPSTREAM}|g" {} \;
fi

# Custom initialization
if [[ -f /docker-entrypoint-init.d/*.sh ]]; then
    for script in /docker-entrypoint-init.d/*.sh; do
        if [[ -x "$script" ]]; then
            echo "Running $script..."
            "$script"
        fi
    done
fi

# Start nginx
exec "$@"
EOF
}

# =============================================================================
# CADDY DOCKERFILE
# =============================================================================

generate_caddy_dockerfile() {
    local name="$1"
    local output_dir="$2"
    
    cat > "${output_dir}/Dockerfile" << 'EOF'
# Generated by Cerberus
FROM caddy:alpine

# Install additional packages
RUN apk add --no-cache \
    bash \
    curl \
    && rm -rf /var/cache/apk/*

# Create caddy user if not exists
RUN id caddy || adduser -D -h /var/lib/caddy -s /bin/false caddy

# Copy Caddyfile
COPY Caddyfile /etc/caddy/Caddyfile

# Copy custom entrypoint if needed
COPY entrypoint.sh /docker-entrypoint.sh
RUN chmod +x /docker-entrypoint.sh

# Create log directory
RUN mkdir -p /var/log/caddy \
    && chown -R caddy:caddy /var/log/caddy

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:2019/health || exit 1

# Expose ports
EXPOSE 80 443 2019

# Run as caddy user
USER caddy

ENTRYPOINT ["/docker-entrypoint.sh"]
CMD ["caddy", "run", "--config", "/etc/caddy/Caddyfile", "--adapter", "caddyfile"]
EOF

    # Generate entrypoint script
    cat > "${output_dir}/entrypoint.sh" << 'EOF'
#!/bin/bash
# Generated by Cerberus

set -e

# Environment variable substitution in Caddyfile
if [[ -n "${UPSTREAM}" ]]; then
    sed -i "s|http://backend|${UPSTREAM}|g" /etc/caddy/Caddyfile
fi

# Custom initialization
if [[ -d /docker-entrypoint-init.d ]]; then
    for script in /docker-entrypoint-init.d/*.sh; do
        if [[ -x "$script" ]]; then
            echo "Running $script..."
            "$script"
        fi
    done
fi

# Start Caddy
exec "$@"
EOF
}

# =============================================================================
# HAPROXY DOCKERFILE
# =============================================================================

generate_haproxy_dockerfile() {
    local name="$1"
    local output_dir="$2"
    
    cat > "${output_dir}/Dockerfile" << 'EOF'
# Generated by Cerberus
FROM haproxy:alpine

# Install additional packages
RUN apk add --no-cache \
    bash \
    curl \
    openssl \
    && rm -rf /var/cache/apk/*

# Copy HAProxy configuration
COPY haproxy.cfg /usr/local/etc/haproxy/haproxy.cfg

# Copy custom entrypoint if needed
COPY entrypoint.sh /docker-entrypoint.sh
RUN chmod +x /docker-entrypoint.sh

# Create log directory
RUN mkdir -p /var/log/haproxy

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:8404/stats || exit 1

# Expose ports
EXPOSE 80 443 8404

ENTRYPOINT ["/docker-entrypoint.sh"]
CMD ["haproxy", "-f", "/usr/local/etc/haproxy/haproxy.cfg"]
EOF

    # Generate entrypoint script
    cat > "${output_dir}/entrypoint.sh" << 'EOF'
#!/bin/bash
# Generated by Cerberus

set -e

# Validate HAProxy configuration
haproxy -c -f /usr/local/etc/haproxy/haproxy.cfg

# Environment variable substitution
if [[ -n "${UPSTREAM}" ]]; then
    sed -i "s|server backend1.*|server backend1 ${UPSTREAM} check|g" /usr/local/etc/haproxy/haproxy.cfg
fi

# Custom initialization
if [[ -d /docker-entrypoint-init.d ]]; then
    for script in /docker-entrypoint-init.d/*.sh; do
        if [[ -x "$script" ]]; then
            echo "Running $script..."
            "$script"
        fi
    done
fi

# Start HAProxy
exec "$@"
EOF
}

# =============================================================================
# TRAEFIK DOCKERFILE
# =============================================================================

generate_traefik_dockerfile() {
    local name="$1"
    local output_dir="$2"
    
    cat > "${output_dir}/Dockerfile" << 'EOF'
# Generated by Cerberus
FROM traefik:latest

# Install additional packages (using alpine base)
RUN apk add --no-cache \
    bash \
    curl \
    && rm -rf /var/cache/apk/*

# Copy Traefik configuration
COPY traefik.yml /etc/traefik/traefik.yml
COPY dynamic/ /etc/traefik/dynamic/

# Copy custom entrypoint if needed
COPY entrypoint.sh /docker-entrypoint.sh
RUN chmod +x /docker-entrypoint.sh

# Create log directory
RUN mkdir -p /var/log/traefik

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
    CMD traefik healthcheck || exit 1

# Expose ports
EXPOSE 80 443 8080

ENTRYPOINT ["/docker-entrypoint.sh"]
CMD ["traefik"]
EOF

    # Generate entrypoint script
    cat > "${output_dir}/entrypoint.sh" << 'EOF'
#!/bin/bash
# Generated by Cerberus

set -e

# Environment variable substitution
if [[ -n "${UPSTREAM}" ]]; then
    find /etc/traefik/dynamic -name "*.yml" -o -name "*.yaml" | \
        xargs sed -i "s|http://backend|${UPSTREAM}|g"
fi

# Custom initialization
if [[ -d /docker-entrypoint-init.d ]]; then
    for script in /docker-entrypoint-init.d/*.sh; do
        if [[ -x "$script" ]]; then
            echo "Running $script..."
            "$script"
        fi
    done
fi

# Start Traefik
exec "$@"
EOF
}

# =============================================================================
# ANUBIS DOCKERFILE
# =============================================================================

generate_anubis_dockerfile() {
    log_info "Generating Dockerfile for Anubis DDoS protection"
    
    local anubis_dir="${DOCKERFILE_DIR}/anubis"
    safe_mkdir "$anubis_dir"
    
    cat > "${anubis_dir}/Dockerfile" << 'EOF'
# Generated by Cerberus
FROM chaitin/anubis:latest

# The Anubis image is already well-configured
# We just add our custom entrypoint for flexibility

# Copy custom entrypoint if needed
COPY entrypoint.sh /docker-entrypoint.sh
RUN chmod +x /docker-entrypoint.sh

# Copy bot policy
COPY botPolicy.json /app/botPolicy.json

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:9090/metrics || exit 1

# Expose ports
EXPOSE 8080 9090

ENTRYPOINT ["/docker-entrypoint.sh"]
CMD ["/app/anubis"]
EOF

    # Generate entrypoint script
    cat > "${anubis_dir}/entrypoint.sh" << 'EOF'
#!/bin/bash
# Generated by Cerberus

set -e

# Validate bot policy
if [[ -f /app/botPolicy.json ]]; then
    echo "Using custom bot policy"
else
    echo "Warning: No bot policy found"
fi

# Environment setup
export BIND="${BIND:-:8080}"
export DIFFICULTY="${DIFFICULTY:-5}"
export TARGET="${TARGET:-http://proxy-2:80}"
export METRICS_BIND="${METRICS_BIND:-:9090}"
export SERVE_ROBOTS_TXT="${SERVE_ROBOTS_TXT:-true}"

# Custom initialization
if [[ -d /docker-entrypoint-init.d ]]; then
    for script in /docker-entrypoint-init.d/*.sh; do
        if [[ -x "$script" ]]; then
            echo "Running $script..."
            "$script"
        fi
    done
fi

# Start Anubis
exec "$@"
EOF
}

# =============================================================================
# BUILD SCRIPT GENERATION
# =============================================================================

# Generate build script for all Dockerfiles
generate_build_script() {
    log_info "Generating Docker build script"
    
    local build_script="${DOCKERFILE_DIR}/build-all.sh"
    
    cat > "$build_script" << 'EOF'
#!/bin/bash
# Generated by Cerberus
# Build all Docker images

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_NAME="${PROJECT_NAME:-cerberus}"

echo "Building Docker images for $PROJECT_NAME..."

# Build each proxy image
for proxy_dir in "$SCRIPT_DIR"/*/; do
    if [[ -f "$proxy_dir/Dockerfile" ]]; then
        proxy_name=$(basename "$proxy_dir")
        echo "Building $proxy_name..."
        
        # Copy config files if they exist
        config_dir="../../proxy-configs/$proxy_name"
        if [[ -d "$config_dir" ]]; then
            cp -r "$config_dir"/* "$proxy_dir/" 2>/dev/null || true
        fi
        
        # Build image
        docker build -t "$PROJECT_NAME/$proxy_name:latest" "$proxy_dir"
        
        echo "✓ Built $PROJECT_NAME/$proxy_name:latest"
    fi
done

echo "All images built successfully!"
EOF

    chmod +x "$build_script"
}

# =============================================================================
# VALIDATION
# =============================================================================

# Validate generated Dockerfiles
validate_dockerfiles() {
    log_info "Validating Dockerfiles..."
    
    if [[ ! -d "$DOCKERFILE_DIR" ]]; then
        log_error "Dockerfile directory not found: $DOCKERFILE_DIR"
        return 1
    fi
    
    local errors=0
    for dockerfile in "$DOCKERFILE_DIR"/*/Dockerfile; do
        if [[ -f "$dockerfile" ]]; then
            local dir
            dir=$(dirname "$dockerfile")
            local name
            name=$(basename "$dir")
            
            # Check for required files
            if [[ ! -f "$dir/entrypoint.sh" ]]; then
                log_error "Missing entrypoint.sh for $name"
                ((errors++))
            fi
            
            # Basic Dockerfile validation
            if ! grep -q "^FROM" "$dockerfile"; then
                log_error "Invalid Dockerfile for $name: missing FROM instruction"
                ((errors++))
            fi
            
            log_info "Validated Dockerfile for $name"
        fi
    done
    
    if [[ $errors -eq 0 ]]; then
        log_info "All Dockerfiles validated successfully"
        return 0
    else
        log_error "Dockerfile validation failed with $errors errors"
        return 1
    fi
}

# =============================================================================
# INITIALIZATION
# =============================================================================

# Initialize generator
if [[ "${BASH_SOURCE[0]}" != "${0}" ]]; then
    log_debug "Dockerfile generator loaded"
fi